音声追加時
Assets/Audio内に格納
AudioManager.hにenumを追加
audioSource.jsonにKeyでenumを、fileにファイル名、loop/maxPlay/attribute(BGM:0 SE:1)を記述
使いたいクラスでAudioManagerを呼び出し、そのままPlay(enum)

フォント(char)追加時
Assets/Text内に格納
TextLoader.hにenumを追加
charTextSource.jsonにKeyでenumを、fileにファイル名、１文字のw/h, 横の文字数を記述
使いたいクラスでTextを呼び出し、そのままLoad(enum)

衝突判定関係の仕様
Enemy含む破壊系オブジェクトははコリジョン付与
プレイヤーは全検索で移動方向、地面、天井にレイキャスト

マップjson仕様
field:特に床や壁など以外の役目を持たないただのブロックオブジェクト
activeField:何らかのアクションを行うフィールドオブジェクト 追加予定は無いがダメージ床や水など
entity:個別でアクションを行うオブジェクト コリジョンを持ち、破壊される

field:modelハンドルとTransformの構造体リスト
activeField:GameObjectポインタリストで格納
entity:GameObjectポインタリストで格納

ModelLoaderクラス
・全モデルをenumで管理
・モデルファイル名はjson
・ModelのModifyはModel:: LoadのみModelLoader まとめたほうがいいだろ

Fieldクラス
・モデルハンドルと変形データをまとめた構造体を持つ
・表示する機能しかない
・ロードは入れる前のクラスなど別クラスで

Entityクラス

FieldObject
・bool unbreak = true;
・int hModel;
・bool isDraw;
if(dist(this,player)<SysCon::drawDistance)Draw(hModel);
Enemy
・unbreak = false;
・
 
Player
・全FieldObjectとレイキャストなんかしてたら重すぎるため絞りたい
∟敵なども含まれるから　地形だけとしても複数オブジェクトのためキツイｗ
∟地形にparent.Getでプレイヤー引っ張ってくる、距離を各地形オブジェクトで測定、したところで下方向しか見ない
∟じゃ地形全部か 最低値を更新する形　地形オブジェクト1個なら有難いんだけど ってかどうせFindObjectで全検索するのでいいかも←それも１個しか来ないけども
∟床判定できたとき、前回座標と次回座標で角度を求める 66度以下であれば移動可能 66度超は前回座標に戻す
各オブジェクトに属性付与して管理は
Defaultはそもそも判定しないため付加形式であればいらない 変更形式ならいる
Field,地形オブジェクト 可動オブジェクトの地形判定対象
Entity,可動オブジェクト 自身で動くことができる
noGravity,重力無効 重力無効化
Default:Neutral,中立オブジェクト Player,Enemyの攻撃判定対象
Enemy,敵オブジェクト Playerの攻撃判定対象
Player, プレイヤーオブジェクト Enemyの攻撃判定対象

Default:Safe, 非攻撃性オブジェクト 衝突判定時に攻撃判定を行わない
Strike, 攻撃性オブジェクト 衝突判定時に攻撃判定を行う

Objectの付加値アレコレ
power:0 常に自身が向いている方向へ動く力
killTime:600(frame) 最大生存秒数 -1は消えない
antiGravity:0(0~1 割合) 重力のかかり具合 

・PlayerはObjectを全検索し、isLandがあればレイを飛ばし判定する 重そうであればdistanceで制限かけてもいい 長距離など見ないので

Object
・全ゲームオブジェクト
・初期配置用 ほぼGameObjectと同じ
・特に特別な機能は無い
・何か判定する際はここで基本的な機能を記述する
・isLand;

Field extends Object
・常に表示される
・isLand = true;

Cube extends Field
・四角形

RTP extends Field
・直三角柱

Cylinder extends Field
・円柱

Water extends Field
・水
・isLand = false;
・重力影響1/2 最大落下速度=重力9.8

Entity extends Object
・プレイヤー基準で表示されなくなる 判定はPlayerではなくこっちで
・コリジョンが存在する
・isGravity = true; 重力判定が行われる
・isInvinsible = false; 無敵判定

Block extends Entity
・壊せるブロック
・破壊時にItemを生成するかもしれない GetParent()を親にして自分はKill
・isGravity = false;
・isLand = true;

Enemy extends Entity
・Enemy属性付与目的
・各種敵オブジェクトはここから派生する

Neutral extends Entity

***************Playerについて***************
方向系はTankGameを ハンガーはSTGを 移動はPackmanを参考にする ここで過去の活用ができる

Init(vector<audioList>)からのPlay<List>したら
audiOListを初期化時に用意する必要
どうせ変わらない

https://qiita.com/hoshianaaa/items/108ae9edab791fe5e77d

**合説にて**
割と他コンテンツの知識など活用するのはTAの面が強いかもしれない
ゲームのある一部分を特化させるほうが評価されるため、なかなか

わりかし今特化部分無くて悲しい.....

機能追加をメインにしているならドキュメントを作るだけでも大きい
使ってもらえるのが良いEND ゲームはその追加した機能を前面に出すものを作ればよい



ルービックキューブを元にしたゲームに
ブロック
・立方体
・各地形は上下左右前奥に効果マスを設置可能
・マスにより効果発動
　<↑：隣が↑方向に90度回転
  <>
  ↑：両隣が↑方向に90度回転
　●：対応する●へ移動　土管？転移？
　Ｇ：このマスがある面が揃うとこのマスの上にフラッグが生成される　とるとクリア
　□：このマスを踏むと色が出現する
　
💃▱
 |/ ：隣接する面へ移動
　□|点線四角：複製　まだ決めてない

落下すると落下前の面の真ん中に移動する
それだけのゲーム

ゲ制の提出用なのでこれだけは完成させないと留年する

Blockクラス
Tile up,down,left,right, front, back;=nullptr;
Tile nextUp, nextDown, nextLeft, nextRight, nextFront, nextBack;
ROTATE{
FRONT,
BACK,
CW,
CCW
}
Rotate(ROTATE rot){
switch(rot){
case FRONT:
nextPos GameConfig::GameSpeed
}
}
pushButton(bHnd b)

GameConfig{
VIEWMODE{
FPS,
TPS,
FREE
}

VIEWMODE viewmode = FPS; Get/Set
bool enableFreeView = false; Get/Set

}


===========================================================================================================

親を変えて処理を行っても最後に親を戻すなら面倒になる→結局中心点を指定した移動を書かないといけない

A地点を中心に距離1で座標を指定する、回転はその進捗でよい
[0,0,0](-1,-1,-1)
[1,1,0]( 0, 0,-1)

  -1 0 1
-1
 0
 1

-1,1→-1,-1
-1,0→0,-1
-1,-1→1,-1
0,1→-1,0
0,0→0,0
0,-1→1,0
1,1→-1,1
1,0→0,1
1,-1→1,1

zPos = y-1;
yPos = z-1*-1;

===========================================================================================================

00 01 02
10 11 12
20 21 22
[col][0][z], [col][z][0]
swap(y0zn⇔ynz0)
02 10 20
01 11 12
00 21 22
swap(y1zn⇔ynz1) z1以上
02 10 20
01 11 12
00 21 22

02 12 22
01 11 21
00 10 20

for(y){
 for(z){
  

00 01 02
10 11 12
20 21 22

02 12 22
01 11 21
00 10 20

このアルゴリズムが通用する場所
X軸移動全部([X][y][z])
Y軸移動全部([x][Y][z])
X軸移動全部([x][y][Z])

逆もまあ3x3ならできる 5x5とかそのとき考えりゃいいか
123 00 01 02
456 10 11 12
789 20 21 22

swap(y0zn⇔ynz0)
347 02 10 20 123
256 01 11 12 456
189 00 21 22 789

swap(y0zn⇔ynz0)
347 02 10 20 123
256 01 11 12 456
189 00 21 22 789

369 02 12 22 169
258 01 11 21 458
147 00 10 20 723


  002  102  202
 001  101  201
000  100  200
  012  112  212
 011  111  211
010  110  210
  022  122  222
 021  121  221
020  120  220

//〇×にしていいんじゃね
毎回48回？いいえ 回転時は１～2面は判定しなくてもよい
置いた場所は最大2～4カ所のみでよい


//やばい天啓が降りた 奇数の反時計変形ができるやつ
//考えていた挙動を逆にした挙動をしているが原理としては合っているためOK 偶数処理もした
#include <iostream>
#include <vector>
using namespace std;
void printArr(vector<vector<vector<int>>> arr, int singlePrintX = -1){
    if(singlePrintX == -1){
    for (int x = 0; x < arr.size();x++) {
        cout << "x=" << x << endl;
        for (int y = 0; y < arr[0].size();y++) {
            for (int z = 0; z < arr[0][0].size();z++) {
                cout << arr[x][y][z] << " ";
            }
            cout << endl;
        }
    }
    }else{
        
        cout << "x=" << singlePrintX << endl;
        for (int y = 0; y < arr[0].size();y++) {
            for (int z = 0; z < arr[0][0].size();z++) {
                cout << arr[singlePrintX][y][z] << " ";
            }
            cout << endl;
        }
    }
}
int main(void){
    // Your code here!
    int num = 10;
    vector<vector<vector<int>>> arr;
    arr.resize(num, vector<vector<int>>(num, vector<int>(num)));
    for (int x = 0; x < arr.size();x++) {
        for (int y = 0; y < arr[0].size();y++) {
            for (int z = 0; z < arr[0][0].size();z++) {
                arr[x][y][z] = x*100 + y*10 + z;
            }
        }
    }
    printArr(arr,0);
    int swapCount = num;
    for(int row = 0; row < num; row++){
        cout << "row,swapCount:" << row << "," << swapCount << endl;
        for(int col = num-swapCount; col < num; col++){
            cout << "[" << row << "," << col <<"]<->[" << col << "," << num-1-row << "]" << endl;
            swap(arr[0][row][col], arr[0][col][num-1-row]);
        }
        printArr(arr,0);
        
        cout << "row:" << row << endl;
        if(row != num/2){
            if(row > num/2){
                swapCount++;
            }else{
                swapCount--;
            }
        }else{
            if(num %2 == 0)swapCount++;
        }
        cout << "swapCount=" << swapCount << endl;
    }
    
    printArr(arr,0);
}

//簡略化
#include <iostream>
#include <vector>
using namespace std;
int main(void){
    int num = 5;
    vector<vector<vector<int>>> arr;

    //初期化
    arr.resize(num, vector<vector<int>>(num, vector<int>(num)));
    for (int x = 0; x < arr.size(); x++) {
        for (int y = 0; y < arr[0].size(); y++) {
            for (int z = 0; z < arr[0][0].size(); z++) {
                arr[x][y][z] = x * 1 + y * 10 + z*100;
            }
        }
    }

    int swapCount = num;

    //入れ替え回数の更新
    auto ModifySwapCount = [num, &swapCount](int row) {
        if (row != num / 2) {
            if (row > num / 2)    swapCount++;
            else    swapCount--;
        }
        else if (num % 2 == 0)   swapCount++;
        };
    enum ROTATE_AXIS {
        X,
        Y,
        Z
    };

    //配列入替
    //axisRot:回転軸 axisCol:[0][0][0]を基準に何行目を入れ替えるか isCC:エンジンの回転軸から時計回りかどうか
    auto swapArr = [&num, &swapCount, &arr, &ModifySwapCount](ROTATE_AXIS axisRot, int axisCol, bool isCC) {
        if (isCC) {
            for (int row = 0; row < num; row++) {
                for (int col = num - swapCount; col < num; col++) {
                    switch (axisRot) {
                    case ROTATE_AXIS::X:
                        //x軸の時計回転 前から見て上
                        swap(arr[axisCol][col][row], arr[axisCol][num - 1 - row][col]);
                        break;
                    case ROTATE_AXIS::Y:
                        //y軸の時計回転 前から見て左
                        swap(arr[col][axisCol][row], arr[num - 1 - row][axisCol][col]);
                        break;
                    case ROTATE_AXIS::Z:
                        //z軸の時計回転 前から見て"反時計"
                        swap(arr[col][row][axisCol], arr[num - 1 - row][col][axisCol]);
                        break;
                    default:
                        //Messagebox();
                        break;
                    }
                    ModifySwapCount(row);
                }
            }
        }
        else {
            for (int row = 0; row < num; row++) {
                for (int col = num - swapCount; col < num; col++) {
                    switch (axisRot) {
                    case ROTATE_AXIS::X:
                        //x軸の反時計回転 前から見て下
                        swap(arr[axisCol][row][col], arr[axisCol][col][num - 1 - row]);
                        break;
                        //y軸の反時計回転 前から見て右
                    case ROTATE_AXIS::Y:
                        swap(arr[row][axisCol][col], arr[col][axisCol][num - 1 - row]);
                        break;
                    case ROTATE_AXIS::Z:
                        //z軸の反時計回転 前から見て"時計"
                        swap(arr[row][col][axisCol], arr[col][num - 1 - row][axisCol]);
                        break;
                    default:
                        //Messagebox();
                        break;
                    }
                }
                ModifySwapCount(row);
            }
        }
    };

    swapArr(ROTATE_AXIS::Z, 1, true);
}

==================================================
上方向(x軸時計)
　上後　前上
左前右左下右
　下　　後　

下方向(x軸反時計)
　上後　後下
左前右左上右
　下　　前　

左方向(y軸時計)
　上後　上左
左前右前右後
　下　　下　

右方向(y軸反時計)
　上後　上右
左前右後左前
　下　　下　

時計方向(z軸反時計)
　上後　左後
左前右下前上
　下　　右　

反時計方向(z軸時計)
　上後　右後
左前右上前下
　下　　左　

=================================================
○×ゲーの3Dバージョンを作ることにした
Title:OXGame 3D
・各面のどれかで縦横斜めのどれか1列を完成させると勝利
・自分のターンでは
　・盤面に自身のマークを設置する
　・盤面を回転させる
のどちらか片方ができる
・回転後にいずれかの面で３つ自分のマークが並んだ場合、自身は勝利する。
・回転後にいずれかの面で３つ相手のマークが並んだ場合、相手が勝利する。
・回転後にいずれかの面で３つ自分のマークと相手のマークが並んだ場合、"相手"が勝利する。

詳細なルール
・回転後の同時完成は、その完成数にかかわらず相手が勝利する。
・全てのマスが埋まった時、その後回転させて勝てる面があっても、強制的に引き分けとなる。
・パスはできない。

できれば選択式で追加したいルール
・三三禁止
　・○のみ ・両方
・回転後の回転
　・有効/無効

================================================
【エフェクシア】
エフェクトの補助ツール
使用ヘッダに
    #include "./Include/EffekseeLib/EffekseerVFX.h"
    public:
        std::shared_ptr<EFFEKSEERLIB::EFKTransform> mt;

ソースに
Initialize()内
    EFFEKSEERLIB::gEfk->AddEffect("エフェクト名(任意)", "Effect\\〇〇〇.efk"); ※ファイル名は私の場合Assets/Effect/内にｍためEffetct\\をつける
    EFFEKSEERLIB::EFKTransform t;
    DirectX::XMStoreFloat4x4(&(t.matrix), transform_.GetWorldMatrix());
    t.isLoop = true;    //ループするか
    t.maxFrame = 120;   //最大フレーム指定
    t.speed = 1.0;      //エフェクト速度 ※エクスポート時の速度が1.0
    mt = EFFEKSEERLIB::gEfk->Play("先述のエフェクト名", t);
Update()内
    DirectX::XMStoreFloat4x4(&(mt->matrix), this->GetWorldMatrix());    //これを記述するとこのオブジェクトの座標が変わるとエフェクトも動く
エフェクトのエクスポート方法
エディタでefkprojファイルを開く
気に食わなければ速度を変えたりフレームを変える
エクスポートしefkファイルを生成
ModelとTextureをコピー(F2で使用アセットが見れるためそれだけ導入でもよい)

(初期導入)
libとincludeに追加、Mainにinitialize,update,draw,deltaTimeを追加する


========================
・回転モード時のインジケータ（新しくモデル作ろう おとなしく）
・置けない場所での赤インジケータ モデルのアニメ追加でよい
・とりあえず置けるようにしてみる 
・判定をつける
・ボタンでオプション
・オプションはタイトルへ戻る/音量/画面サイズ/フルスクリーンを選択 キーコンはしない
・過去のRunGameからカメラ振動をパクる


==========================
0 1 234
1 2 34
2 3 4
3 4
022   222
Fro121Right Back  Left
020   220   222   022   020
   110   211   112   011
000   200   202   002   000
   101
002   202 Bottom

Front
⤴0-2 0-2 0
⤵0-2 2-0 0
Right
⤴2 0-2 0-2
⤵2 2-0 0-2
Back
⤴2-0 0-2 2
⤵2-0 2-0 2
Left
⤴0 0-2 2-0
⤵0 2-0 2-0

Top
⤴0-2 2 0-2
⤵0-2 2 2-0
Bottom
⤴0-2 0 2-0
⤵0-2 0 0-2

↓これカメラのXとY全部逆
unit = 90/PIECES;(unit=30)
15=Half(unit)
2=PIECES-1

if(camY > 45)surface=TOP; tmp=true;
elif(camY < -45)surface=BOTTOM; tmp=true;

y=1;

//y指定
int count = 0;
for(int minAngle = -15; minAngle < = 45; minAngle += unit){
	if(camY < minAngle){
		y=count;
		break;
	}el count++;
}
//xz指定
if(abs(cX)>105)z=2;
elif(abs(cX)>75)z=1;
el z=0;

if(abs(cX)>165)x=1;
elif(cX < -15)x=0;
elif(cX > 15)x=2;
el x=1;
if(abs(cX) < 45)FRONT;
elif(abs(cX) > 135)BACK;
elif(cX < 0)LEFT;
el RIGHT;

/*
if(-165 < cX < -135)x=2 z=2 BACK
if(-135 < cX < -105)x=2 z=2 RIGHT
if(-105 < cX < -75)x=2 z=1 RIGHT
if(-75 < cX < -45)x=2 z=0 RIGHT
if(-45 < cX < -15)x=2 z=0 FRONT
if(-15 < cX < 15)x=1 z=0 FRONT
if(15<cX<45) x=0 z=0 FRONT
if(45<cX<75) x=0 z=0 LEFT
if(75<cX<105) x=0 z=1 LEFT
if(105<cX<135) x=0 z=2 LEFT
if(135<cX<165) x=0 z=2 BACK
if(165<cX or cX <-165) x=1 z=2 BACK
*/

if(-165 < cX < -135)c=2 DOWN c=x
if(-135 < cX < -105)c=2 CCW c=z
if(-105 < cX < -75)c=1 CCW
if(-75 < cX < -45)c=0 CCW
if(-45 < cX < -15)c=2 UP c=x
if(-15 < cX < 15)c=1 UP
if(15<cX<45) c=0 UP
if(45<cX<75) c=0 CW c=z
if(75<cX<105) c=1 CW
if(105<cX<135) c=2 CW
if(135<cX<165) c=0 DOWN c=x
if(165<cX or cX <-165) c=1 DOWN









FRONT
dir=UP/DOWN W=UP A=-1,<0=0 S=DOWN D=+1,>2=2
dir=LEFT/RIGHT W=+1 A=LEFT S=-1 D=RIGHT
dir=CW/CCW if(cX>0)W=+1 A=CCW S=-1 D=CW else W=-1 A=CW S=+1 D=CCW


引き分け処理
前回回転と反対方向を指定できなくする処理
投了ボタン
1P2Pで操作ボタン変える
キーボードでもカメラ操作できるようにする スネ夫のマリルイ参考
 
アセット インジケータ場所変えるときの音選定を忘れてる
オプションは戻るしかないやつと再開/タイトルに戻るの2パターンでやる？ちぇいさー参考に